//Example 3.1 has to be like this : 
#include <limits>
#include <iostream>
using namespace std;
int main(void)
{
	int num = __INT_MAX__ - 2;
	int cnt = 0;
	cout << "Integer overflow in C++:" << endl;  // the book texts has forgotten the 2nd << 
	cout << "Incrementing from " << num << endl;
	while (cnt < 5)
	{ num = num + 1;
	  cnt = cnt + 1;
	  cout << cnt << "   " << num << endl; }
	cout << "Thank you for worrying about integer limits" << endl;
	return 0;
}

//Another way to implement it is :
#include <climits>
#include <iostream>
using namespace std;
int main(void)
{
	int num = INT_MAX - 2;
	int cnt = 0;
	cout << "Integer overflow in C++:" << endl;  // the book texts has forgotten the 2nd << 
	cout << "Incrementing from " << num << endl;
	while (cnt < 5)
	{ num = num + 1;
	  cnt = cnt + 1;
	  cout << cnt << "   " << num << endl; }
	cout << "Thank you for worrying about integer limits" << endl;
	return 0;
}
//A usefull command is 
// grep -r INT_MAX /usr/include/* | grep limits


//Example 5.3 should be like this, for my g++ compiler to accept it.
#include <iostream>
using namespace std;
int main(void)
{
	int  a[3], size[4]; 
	a[0]=11; a[1]=12; a[2]=13;
	size[1]=39;size[2]=40;size[3]=41;size[4]=42;
	for(int i=1;i<=4;i++) cout<<" "<<size[i];
	cout << endl;
	for(i=0;i<3;i++) cout<<" "<<a[i];
	cout<<endl;
	return 0;
}
//And by running 
//g++ -Wall -fpermissive  -o Chap5example5.3  Chap5example5.3.cpp
//the definition of int i inside the for loop is accepted , and an executable is produced.
//However I do not get the results that the book wants to show , I get 
39 40 41 42 
42 12 13
//which means that a[0] has assumed the 11 value , but it has been overwritten 
//by the overflow of element size[4] . If I were to define array size[5] , my x86_64 machine
//would allocate many more bytes for size[] , actually 8*sizeof(int) ,and to see the overflow
//I would have to make a main() like this
	int  i, a[3], size[7]; //size[5] or size[6] ...  up to size[8] is the same
	a[0]=11; a[1]=12; a[2]=13;
	size[1]=39;size[2]=40;size[3]=41;size[4]=42;
	size[5]=59;size[6]=60;size[7]=61;size[8]=62;
	for(i=1;i<=7;i++) cout<<" "<<size[i];
	cout << endl;
	for(i=0;i<3;i++) cout<<" "<<a[i];
	cout<<endl;
	return 0;
//with output 
 39 40 41 42 59 60 61 
 62 12 13


//Example 5.16 ,an improvement from the book code , using a function
#include <iostream>
#include <cstring>
using namespace std;
union StreetOrPOB	// alternative interpretations
{ char street[30];
  long int POB;   } ;
struct Address
{ char fullname[30];
  int kind;			// 0: street address; 1: P.O.B.
  StreetOrPOB second;  // either one or the another meaning
  char city[30];   } ;
void display(Address someadr)  //display function,not used in the book
{
	cout << someadr.fullname << endl;
	if (someadr.kind == 0)		// check data interpretation
		cout << someadr.second.street << endl;
	 else
		cout << "P.O.B. " << someadr.second.POB << endl;
	cout << someadr.city << endl;   cout << endl;
}
int main ()
{
	Address a1, a2;
	strcpy(a1.fullname,"Doe, John");
	strcpy(a1.second.street,"15 Oak Street"); a1.kind = 0;
	strcpy(a1.city,"Anytown, MA 02445");
	strcpy(a2.fullname,"King, Amy");
	a2.second.POB = 761; a2.kind = 1;		// address with POB
	strcpy(a2.city,"Anytown, MA 02445");
	display(a1);  //here the book has all the lines of code to display...
	display(a2);  //... and repeats them again , so I thought I could make a function!
	return 0;
}

//Example 6.5 , there are 2 mistakes (I corrected them on line 118 and 121 here)
#include <iostream>
using namespace std;
int main()
{
	int i;  int* pi; char* pc ;	// noninitialized pointers [the book has it: int i;int pi;char* pc; ]
	pi = &i;				// this turns pointer to i
	*pi = 502;				// this is ok, it effects in i = 502;
	if (*pi>0)   *pi = 28791;	//just a show off,same as: if(i>0) i=28791 [book has it : if(*pi>0) *pc=28791]
	pc = (char*) &i;			// some compilers will accept : pc = &i;
	int a1 = *pi;			// access to i through pointer
	int a2 = *pc;			// access to i through pointer
	cout << " i as decimal: " << i << endl
		 << " i as hex: " << hex << i << endl;
	cout << " i through int pointer: " << dec << a1 << endl;
	cout << " i through char pointer: " << a2 << endl;
	cout << " i through char pointer in hex: " << hex << a2 << endl;
	return 0;
}

//Example 6.10 , the book code was missing a brace }
//and the program would not compile. I found it , added it , and also did 
//all the improvements that were suggested in the next 2 pages of the book. It is 
//a habit for the writer to present a low quality solution initially , and add improvements
//in the next 2-3 pages of the original code , as he explains to the reader several stuff.
#include <iostream>
#include <iomanip>
using namespace std;
int main (void)
{
	const int NUM = 3;		// for exibition purposes (normally it should be larger)
	double  total = 0, *data;
	int count = 0, size = NUM;		// initialize current data
	data = new double[size];		// initial un-named array on the heap,is only NUM elements big
	do {				// do until zero is entered from user
		double amount;	//for user input
		cout << " Enter amount (or 0 to finish): ";
		cin >> amount;		// get next double value by user
		if (amount == 0) break;		// user wants to finish entering amounts
		if (count == size)		// lack of space, ask for more START 
		   { 
			double *q = new double[2*size];		//new pointer,points to doubled array size
			if (q == 0) 		      //for some reason new memory on the heap could not be allocated
				{ cout <<" Out of heap memory: input was terminated" <<endl;break; }
			else 						//new pointer q was succesfully created...
			   {
				cout << "More memory allocated: size = " << size  //...so inform the user about this
					 << " at position " << q << endl;  //not in the book,put it for demonstration
				for (int i=0; i < size; i++)		// copy old data, populate q
				   q[i] = data[i];				// using subscript notation
				size = size * 2;				//update value to reflect doubled size
				delete [] data;			// do not forget to free old smaller array data
				data = q; 		// bind array to the newly created (and populated) pointer
			   }				
		    }				// lack of space, ask for more END (missing from the book)
		total += amount;		// process current valid data...
		data[count++] = amount;	 // ...and get next input value
		} while (true);
	cout << "\n Total of " << count << " values is "	<< total << endl;
	if (count == 0) return 0;		// no results if no input
	cout << "\n Transaction no. Amount\n\n";		// print the table header
	cout.setf(ios::fixed);		// set up fixed format for double
	cout.precision(2);  		//or (if ios::fixed not present) total digits 
	for (int i = 0; i < count; i++)		// go over the data again
	  { 
		cout << setw(4); cout << i+1;			// transaction number
		cout << setw(11); cout << data[i] << endl; 	// transaction value
	  }		
	delete [] data; 		//free memory from the heap (do not rely on Operating System to do it)
	return 0;
}



//Example 6.11 , one missing header for cstrings and one typo mistake 
//the line: strcpy(temp,buf);
//was writen as:  strcpy(temp,buf);}
//It seems that the writer misses often braces , or puts extra braces!
#include <iostream>
#include <cstring>  //missing from the book
using namespace std;
int main(void)
{
	const int LEN = 8; int len=1;		// short array to demonstrate dynamic expansion
	char buf[LEN], *data = 0;		// char-pointer initiallized to zero for first pass
	cout << " Type text, press Enter: \n";
	do 
		{
			cin.get(buf,LEN);	// user data goes into the stack array buf,in LEN-1 character chunks
			len += strlen(buf);		// increase len to len-of-buf+len
			char *temp = new char[len];	// request new un-named heap array,pointed-to by temp
			if (temp == 0)			// heap memory allocation failed?
			  { cout << " Out of memory: program terminated\n";return 0; }	// inform user, exit
			if (data == 0)       //the value of pointer data has remained 0 for the 1st passing
			   strcpy(temp,buf); 		// 1st copy of data from input buffer(will happen only once)
			  else
			   {strcpy(temp,data); strcat(temp,buf); }		//this happens all next times
			delete [] data;						// delete existing array
			data = temp;					// point data to the new array
			cout << " Total: " << len << " , added: " << buf << endl;
			cout << " Dynamic buffer: " << data << endl;			// debug
			char ch = cin.peek();		// what is left in the buffer, after cin.get(buf,LEN); ?
			if (ch == '\n')			//if it's new line(user wants to finish and pressed enter)... 
			  { ch = cin.get(); break; }	//...we exit the do-while loop
		} while (true);				// or keep going until EOF
	cout << "\n You entered the following line: \n\n";
	cout << data << endl;			// same syntax as for arrays
	delete [] data;
	return 0;
}



//Example 6.12 , header files missing, and a wrong ' at line:
// cout <<"Allocated " << len+1 <<": " << data << endl;
//which in the book is typed as 
// cout <'<"Allocated " << len+1 <<": " << data << endl;
#include <iostream>
#include <cstring>  //missing from the book
//#include <cstdio>   //also missing from book , EOF is defined here as -1. Alternatively, define it:
#define EOF -1
using namespace std;
int main(void)
{
	const int LEN = 8; char buf[LEN];
	int cnt = 0;
	cout << "Enter data (or press Return to end): \n";
	do 
		{			// start of outer loop for input lines
			char *data = new char[1]; data[0] = 0;		// initially, it is empty
			int len = 0;		// initial size is zero
			do {			// start of inner loop for line segments
				 cin.get(buf,LEN);		// get next line segment
				 len += strlen(buf);		// expand total string length
				 char *temp = new char[len+1];
				 strcpy(temp,data); strcat(temp,buf);  //transfer letters
				 delete data;
				 data = temp;		// expand the long line
				 cout <<"Allocated " << len+1 <<": " << data << endl;
				 char ch = cin.peek();		// what is left in the buffer?
				 if (ch == '\n' || ch == EOF)		// quit if if user gave just a new line
				   { ch = cin.get();	break; }	// but first remove this '\n' from input
				} while (true);
			if (len == 0) break;		// end on empty string
			cout << " line " << ++cnt << ": " << data << endl;
			delete [ ] data;
		} while (true);		// continue until break on empty line
	return 0;
}
