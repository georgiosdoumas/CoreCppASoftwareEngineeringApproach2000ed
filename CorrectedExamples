//Example 3.1 has to be like this : 
#include <limits>
#include <iostream>
using namespace std;
int main(void)
{
	int num = __INT_MAX__ - 2;
	int cnt = 0;
	cout << "Integer overflow in C++:" << endl;  // the book texts has forgotten the 2nd << 
	cout << "Incrementing from " << num << endl;
	while (cnt < 5)
	{ num = num + 1;
	  cnt = cnt + 1;
	  cout << cnt << "   " << num << endl; }
	cout << "Thank you for worrying about integer limits" << endl;
	return 0;
}

//Another way to implement it is :
#include <climits>
#include <iostream>
using namespace std;
int main(void)
{
	int num = INT_MAX - 2;
	int cnt = 0;
	cout << "Integer overflow in C++:" << endl;  // the book texts has forgotten the 2nd << 
	cout << "Incrementing from " << num << endl;
	while (cnt < 5)
	{ num = num + 1;
	  cnt = cnt + 1;
	  cout << cnt << "   " << num << endl; }
	cout << "Thank you for worrying about integer limits" << endl;
	return 0;
}
//A usefull command is 
// grep -r INT_MAX /usr/include/* | grep limits


//Example 5.3 should be like this, for my g++ compiler to accept it.
#include <iostream>
using namespace std;
int main(void)
{
	int  a[3], size[4]; 
	a[0]=11; a[1]=12; a[2]=13;
	size[1]=39;size[2]=40;size[3]=41;size[4]=42;
	for(int i=1;i<=4;i++) cout<<" "<<size[i];
	cout << endl;
	for(i=0;i<3;i++) cout<<" "<<a[i];
	cout<<endl;
	return 0;
}
//And by running 
//g++ -Wall -fpermissive  -o Chap5example5.3  Chap5example5.3.cpp
//the definition of int i inside the for loop is accepted , and an executable is produced.
//However I do not get the results that the book wants to show , I get 
39 40 41 42 
42 12 13
//which means that a[0] has assumed the 11 value , but it has been overwritten 
//by the overflow of element size[4] . If I were to define array size[5] , my x86_64 machine
//would allocate many more bytes for size[] , actually 8*sizeof(int) ,and to see the overflow
//I would have to make a main() like this
	int  i, a[3], size[7]; //size[5] or size[6] ...  up to size[8] is the same
	a[0]=11; a[1]=12; a[2]=13;
	size[1]=39;size[2]=40;size[3]=41;size[4]=42;
	size[5]=59;size[6]=60;size[7]=61;size[8]=62;
	for(i=1;i<=7;i++) cout<<" "<<size[i];
	cout << endl;
	for(i=0;i<3;i++) cout<<" "<<a[i];
	cout<<endl;
	return 0;
//with output 
 39 40 41 42 59 60 61 
 62 12 13


//Example 5.16 ,an improvement from the book code , using a function
#include <iostream>
#include <cstring>
using namespace std;
union StreetOrPOB	// alternative interpretations
{ char street[30];
  long int POB;   } ;
struct Address
{ char fullname[30];
  int kind;			// 0: street address; 1: P.O.B.
  StreetOrPOB second;  // either one or the another meaning
  char city[30];   } ;
void display(Address someadr)  //display function,not used in the book
{
	cout << someadr.fullname << endl;
	if (someadr.kind == 0)		// check data interpretation
		cout << someadr.second.street << endl;
	 else
		cout << "P.O.B. " << someadr.second.POB << endl;
	cout << someadr.city << endl;   cout << endl;
}
int main ()
{
	Address a1, a2;
	strcpy(a1.fullname,"Doe, John");
	strcpy(a1.second.street,"15 Oak Street"); a1.kind = 0;
	strcpy(a1.city,"Anytown, MA 02445");
	strcpy(a2.fullname,"King, Amy");
	a2.second.POB = 761; a2.kind = 1;		// address with POB
	strcpy(a2.city,"Anytown, MA 02445");
	display(a1);  //here the book has all the lines of code to display...
	display(a2);  //... and repeats them again , so I thought I could make a function!
	return 0;
}

//Example 6.5 , there are 2 mistakes (I corrected them on line 118 and 121 here)
#include <iostream>
using namespace std;
int main()
{
	int i;  int* pi; char* pc ;	// noninitialized pointers [the book has it: int i;int pi;char* pc; ]
	pi = &i;				// this turns pointer to i
	*pi = 502;				// this is ok, it effects in i = 502;
	if (*pi>0)   *pi = 28791;	//just a show off,same as: if(i>0) i=28791 [book has it : if(*pi>0) *pc=28791]
	pc = (char*) &i;			// some compilers will accept : pc = &i;
	int a1 = *pi;			// access to i through pointer
	int a2 = *pc;			// access to i through pointer
	cout << " i as decimal: " << i << endl
		 << " i as hex: " << hex << i << endl;
	cout << " i through int pointer: " << dec << a1 << endl;
	cout << " i through char pointer: " << a2 << endl;
	cout << " i through char pointer in hex: " << hex << a2 << endl;
	return 0;
}

//Example 6.10 , the book code was missing a brace }
//and the program would not compile. I found it , added it , and also did 
//all the improvements that were suggested in the next 2 pages of the book. It is 
//a habit for the writer to present a low quality solution initially , and add improvements
//in the next 2-3 pages of the original code , as he explains to the reader several stuff.
#include <iostream>
#include <iomanip>
using namespace std;
int main (void)
{
	const int NUM = 3;		// for exibition purposes (normally it should be larger)
	double  total = 0, *data;
	int count = 0, size = NUM;		// initialize current data
	data = new double[size];		// initial un-named array on the heap,is only NUM elements big
	do {				// do until zero is entered from user
		double amount;	//for user input
		cout << " Enter amount (or 0 to finish): ";
		cin >> amount;		// get next double value by user
		if (amount == 0) break;		// user wants to finish entering amounts
		if (count == size)		// lack of space, ask for more START 
		   { 
			double *q = new double[2*size];		//new pointer,points to doubled array size
			if (q == 0) 		      //for some reason new memory on the heap could not be allocated
				{ cout <<" Out of heap memory: input was terminated" <<endl;break; }
			else 						//new pointer q was succesfully created...
			   {
				cout << "More memory allocated: size = " << size  //...so inform the user about this
					 << " at position " << q << endl;  //not in the book,put it for demonstration
				for (int i=0; i < size; i++)		// copy old data, populate q
				   q[i] = data[i];				// using subscript notation
				size = size * 2;				//update value to reflect doubled size
				delete [] data;			// do not forget to free old smaller array data
				data = q; 		// bind array to the newly created (and populated) pointer
			   }				
		    }				// lack of space, ask for more END (missing from the book)
		total += amount;		// process current valid data...
		data[count++] = amount;	 // ...and get next input value
		} while (true);
	cout << "\n Total of " << count << " values is "	<< total << endl;
	if (count == 0) return 0;		// no results if no input
	cout << "\n Transaction no. Amount\n\n";		// print the table header
	cout.setf(ios::fixed);		// set up fixed format for double
	cout.precision(2);  		//or (if ios::fixed not present) total digits 
	for (int i = 0; i < count; i++)		// go over the data again
	  { 
		cout << setw(4); cout << i+1;			// transaction number
		cout << setw(11); cout << data[i] << endl; 	// transaction value
	  }		
	delete [] data; 		//free memory from the heap (do not rely on Operating System to do it)
	return 0;
}



//Example 6.11 , one missing header for cstrings and one typo mistake 
//the line: strcpy(temp,buf);
//was writen as:  strcpy(temp,buf);}
//It seems that the writer misses often braces , or puts extra braces!
//Also the if (ch == '\n')  { ch = cin.get(); break; }
//is replaced with 
//if (ch == '\n' || ch==-1)  { ch = cin.get(); break; }
//to accomodate the fact that when user press just enter without typing anything first
//(so it is an empty line, and user strikes ENTER key)
//on some systems (my linux including) this is not an '\n' but an EOF =-1
#include <iostream>
#include <cstring>  //missing from the book
using namespace std;
int main(void)
{
	const int LEN = 8; int len=1;		// short array to demonstrate dynamic expansion
	char buf[LEN], *data = 0;		// char-pointer initiallized to zero for first pass
	cout << " Type text, press Enter: \n";
	do 
		{
			cin.get(buf,LEN);	// user data goes into the stack array buf,in LEN-1 character chunks
			len += strlen(buf);		// increase len to len-of-buf+len
			char *temp = new char[len];	// request new un-named heap array,pointed-to by temp
			if (temp == 0)			// heap memory allocation failed?
			  { cout << " Out of memory: program terminated\n";return 0; }	// inform user, exit
			if (data == 0)       //the value of pointer data has remained 0 for the 1st passing
			   strcpy(temp,buf); 		// 1st copy of data from input buffer(will happen only once)
			  else
			   {strcpy(temp,data); strcat(temp,buf); }		//this happens all next times
			delete [] data;						// delete existing array
			data = temp;					// point data to the new array
			cout << " Total: " << len << " , added: " << buf << endl;
			cout << " Dynamic buffer: " << data << endl;			// debug
			char ch = cin.peek();		// what is left in the buffer, after cin.get(buf,LEN); ?
			if (ch == '\n' || ch==-1)	//if it's new line(user wants to finish and pressed enter)... 
			  { ch = cin.get(); break; }	//...we exit the do-while loop
		} while (true);				// or keep going until EOF
	cout << "\n You entered the following line: \n\n";
	cout << data << endl;			// same syntax as for arrays
	delete [] data;
	return 0;
}



//Example 6.12 , header files missing, and a wrong ' at line:
// cout <<"Allocated " << len+1 <<": " << data << endl;
//which in the book is typed as 
// cout <'<"Allocated " << len+1 <<": " << data << endl;
#include <iostream>
#include <cstring>  //missing from the book
//#include <cstdio>   //also missing from book , EOF is defined here as -1. Alternatively, define it:
#define EOF -1
using namespace std;
int main(void)
{
	const int LEN = 8; char buf[LEN];
	int cnt = 0;
	cout << "Enter data (or press Return to end): \n";
	do 
		{			// start of outer loop for input lines
			char *data = new char[1]; data[0] = '\0';   // initially, it is empty,data[0]=0; would also do
			int len = 0;		// initial size is zero
			do {			// start of inner loop for line segments
				 cin.get(buf,LEN);		// get next line segment
				 len += strlen(buf);		// expand total string length
				 char *temp = new char[len+1];
				 strcpy(temp,data); strcat(temp,buf);  //transfer letters
				 delete data;
				 data = temp;		// expand the long line
				 cout <<"Allocated " << len+1 <<": " << data << endl;
				 char ch = cin.peek();		// what is left in the buffer?
				 if (ch == '\n' || ch == EOF)		// quit if if user gave just a new line
				   { ch = cin.get();	break; }	// but first remove this '\n' from input
				} while (true);
			if (len == 0) break;		// end on empty string
			cout << " line " << ++cnt << ": " << data << endl;
			delete [ ] data;
		} while (true);		// continue until break on empty line
	return 0;
}

//A mistake in the text Chapter6 , paragraph : Dynamic Structures
//The book text is like this :
Some programmers dislike dealing with two selection operators, the arrow and the dot. It is all right to use the uniform
notation, (*q).item for q->item and (*q).next for q->next. Parentheses here are necessary because the selection
operator is of higher priority than the dereferencing operator. Hence, *q.item means *(q.next) and this is a syntax error
because the dot selector operator can be applied to a structure variable only (named or unnamed), not to a pointer.
//The last sentence should be corrected with 
    ..... Hence, *q.item means *(q.item) and this is a syntax error
because the dot selector operator can be applied to a structure variable only (named or unnamed), not to a pointer.



//Example 6.13 , improved commants , and correction of an assumption of the book which is NOT correct
#include <iostream>
#include <iomanip>
using namespace std;
typedef double Item;  //So Item is a synonym for double
struct Node { Item item; Node* next; } ;
int main ()
{ 
	int count = 0;			// count of amounts
	Node *data=NULL, *last;		// pointers to beggining and end of list
	do {					// do until EOF causes failure
		  double amount;			// local variable for input
		  cout << " Enter amount (or 0 to finish): ";
		  //if (amount == 0) break;  //the book has this line but it is not needed here
		  cin >> amount;  	// get next double from user
		  if (amount==0) break;	// stop input when user enters 0 as amount
		  Node* q = new Node;		// create new pointer-to-node on the heap
		  if (q == 0)		// test for success of pointer creation
		    { cout << "Out of heap memory" << endl; break; }
		  q->item = amount;		// fill node with program data,that user gave
		  q->next = NULL;		// update what is considered as last element , now it is q. Then we must take care that last->next no longer is NULL
		  (data == NULL ? data : last->next) = q; //if data was 0 then it is the first element  so data=q , else it is an arbitrary element so last->next = q
		  last = q; //last = last->next;  would NOT be ok
		//last = last->next;  is NOT equivalent (contrary to book assumption),segmentation fault happens and the assignment last->next = q; fails to execute
		  count++; 		// increment count
		} while (true);
	cout << "\nTotal of " << count << " values are loaded\n";
	if (count == 0) return 0;		// no output if no  user input. Program just exits.
	cout << "\nNumber Amount Subtotal\n\n";		// print header
	cout.setf(ios::fixed);		// fixed format for double
	cout.precision(2);		// 2 digits after decimal point
	double total = 0;		// initialize total for input amounts
	Node *q = data;		// start at beggining of the list
	for (int i = 0; i < count; i++)		// go over list data
	{ 
		total += q->item;		// accumulate total
		cout.width(3); cout << i+1;	// transaction number
		cout.width(10); cout << q->item;	// transaction value
		cout.width(11); cout << total << endl;	// running total
		q = q->next; 			// idiom to pointing pointer to next node
	}
	Node *p = data, *r = data;		// initialize traversing pointers
	while (p != NULL)		// go on until it runs off the list
	{ 
		p = p->next;		// prevent next node from hanging
		delete r; r = p; 	// delete node, catch up with next
	}
return 0;
}


//Example 6.14 with small corrections , and the additions for checking operations on ofstream object
//as they are proposed in the text of the book after the listing 6.14
#include <iostream>
#include <cstring>  //missing from the book
#include <fstream>  //for ofstream object
#include <cstdio>   //also missing from book , EOF is defined here as -1. Or define it: #define EOF -1
using namespace std;
int main(void)
{
	const int LEN = 8; char buf[LEN];
	int cnt = 0;
	ofstream outpfile("Chap6exampl6_14.out");
	if (outpfile.fail())		// test for success, give up if not
	  { cout << "Cannot open file" << endl; return 0; }
	cout << "Enter data (or press Return to end): \n";
	do 
		{			// start of outer loop for input lines
			char *data = new char[1]; data[0] = '\0';		// initially, it is empty
			int len = 0;		// initial size is zero
			do {			// start of inner loop for line segments
				 cin.get(buf,LEN);		// get next line segment
				 len += strlen(buf);		// expand total string length
				 char *temp = new char[len+1];
				 strcpy(temp,data); strcat(temp,buf);  //transfer letters from data to temp,append buffer after temp
				 delete []data;
				 data = temp;		// expand the long line
				 int ch = cin.peek();		// what is left in the buffer?
				 if (ch == '\n' || ch == EOF)		// quit if  user gave just a new line
				   { ch = cin.get();	break; }	// but first remove this '\n' from input
				} while (true);
			if (len == 0) break;		// end on empty string
			cout << " line " << ++cnt << ": " << data << endl;  //just to inform the user what is going on
			outpfile << data << endl;
			if (outpfile.fail())		// test for success of writing to output file
			  { cout << "Disk is full, output terminated" << endl; break; }
			delete [ ] data;
		} while (true);		// continue until break on empty line
	cout << "Data is saved in file Chap6exampl6_14.out" << endl;
	return 0;
}


//Chapter 7 Function Name Overloading
// After the NOTE , the writer has a discussion about functions that rreturn the maximum
// and he continues with an example of functions that return the minimum of 2 numbers. So he goes :
"Come to think of it, using two functions, maxLong() and maxDouble(), might not
 be such a bad idea. Especially because this is not the end. Let us consider two other overloaded functions.
 int min (int x, int y)		// return the minimum value
   { return x>y ? x : y; }
 double min(double x, double y)	// it is different from int
  { return x>y ? x : y; }
"
But of course these functions do not return the minimum , it is just a copy-paste from the previous discussion.
He forgot to edit and have the functions like this:
 int min (int x, int y)		// return the minimum value
   { return x<y ? x : y; }
 double min(double x, double y)	// it is different from int
  { return x<y ? x : y; }


//Example 8.7 , with small modifications 
//Notice: basic protection against bad user input (for example if user enters letters instead of numbers)
#include <iostream> 		// encapsulation with server functions
using namespace std; 
struct Cylinder { double radius, height; } ; 
void enterData(Cylinder &c, const char *numbertext)  //book doesn't use the const keyword.I use it to avoid a warning of g++ Wall
{ 
	cout << "Enter radius and height of the " << numbertext << " cylinder: ";
	cin >> c.radius >> c.height; 		// initialize cylinder
}
void validateCylinder(Cylinder c)
{ 
	if (c.radius < 0) c.radius = 10;		// defaults for corrupted data
	if (c.height < 0) c.height = 20; 
}
double computeVolume(const Cylinder& c) 		
 { return c.height * c.radius * c.radius * 3.141593; }
void scaleCylinder(Cylinder &c, double factor)		// scale dimensions
 { c.radius *= factor; c.height *= factor; }
void printCylinder(const Cylinder &c)			// print object state
 { cout << "radius: " <<c.radius << " height: " <<c.height <<endl; }
int main()						// pushing responsibility to server functions
{
	Cylinder c1, c2;			// program data
	enterData(c1,"first");		// initialize first cylinder, pass a name : first
	validateCylinder(c1);		// default values for corrupted data
	enterData(c2,"second");		// initialize second cylinder,name : second
	validateCylinder(c2);		// defaults for corrupted data
	if (computeVolume(c1) < computeVolume(c2)) // compare volumes
	{ 
		scaleCylinder(c1,1.2);		// scale it up and
		cout << "\nFirst cylinder changed size\n";	// print size
		printCylinder(c1); 
	}
	else					// otherwise do nothing
    	cout << "No change in first cylinder size" << endl;
	return 0;
}
